// *******************************************************************************
// Project 		Modulation of PWM output waveform from two timers onto a single output pin
// Target 		ATMEL ATmega1281 micro-controller on STK300 board
// Program		Modulator_OC1C_OC0A_1281_C.c
// Author		Richard Anthony
// Date			17th October 2013

// Function		Demonstrates the Modulation feature which facilitates modulation of the waveforms generated by two programmable timers
//				The modulation feature only works wit Timer 0 (OC0A) and Timer 1 (OC1C)
// 				The combined output waveform appears on PORT B bit 7

//				Timer 0 is configured (in PWM mode) to produce a 50% duty cycle at 8Hz on OC0A
//				Timer 1 is configured (in PWM mode) to produce a 50% duty cycle at 0.95 Hz on OC1C (i.e. total cycle is 1.05 seconds)
//				(this value is chosen because it is the slowest the PWM can operate at)

//				The modulated output is thus a half-second burst of the 8 Hz pulses, followed by a half-second period with no pulses
//				You can see four very short pulses on the LED (in a half-second period), followed by a half-second with no pulses

// I/O hardware	Uses on-board LEDs on Port B (output)
//				LED 7 will pulse 4 times in a half-second (caused by timer 0), then be off for a half-second
//				which is due to the 50% duty cycle of timer 1
// *****************************************

#include <avr/io.h>
#include <avr/interrupt.h>

void InitialiseGeneral();
void InitialiseTimer0_PWM_OC0A_8Hz();
void InitialiseTimer1_PWM_OC1C_1Hz();

int main( void )
{
	InitialiseGeneral();
	InitialiseTimer0_PWM_OC0A_8Hz();
	InitialiseTimer1_PWM_OC1C_1Hz();
	
	while(1)
	{
	}
}

void InitialiseGeneral()
{
	DDRB = 0xFF;			// Configure PortB direction for Output
	PORTB = 0xFF;			// Set all LEDs initially off (inverted on the board, so '1' = off)
	
	sei();
}

void InitialiseTimer0_PWM_OC0A_8Hz()	// PWM 8HZ 50% duty OC0A
{
	TCCR0A = 0b10000011;	// Clear OC0A on Compare Match, Fast PWM waveform generation
	TCCR0B = 0b00000101;	// Use 1024 prescaler
	// For 1 MHz clock (with 1024 prescaler) 
	// To achieve 1 second period, need to count 1000000 / 1024 = 976
	// To achieve 1/8 second period, need to count (1000000 / 1024) / 8= 122
	TCNT0 = 255 - 122;					// Count 122, starting at 255 - 122, ending at 255
	OCR0A = (255 - 122) + (122 / 2);	// Set pulse changeover point to be midway (because 50% duty-cycle is needed)
	TIMSK0 = 0b00000001;		// Bit 0 – TOIE0: Timer/Counter0 Overflow Interrupt Enable
								// Do not need interrupts for the waveform - it is generated directly on the output pin
								// but do need the interrupt handler to reset the value in the TCNT0 register when the counter rolls over
}

ISR(TIMER0_OVF_vect) // TIMER0 Overflow Interrupt handler A (for Modulator)
{
	TCNT0 = 255 - 122;			// Count 122, starting at 255 - 122, ending at 255
}

void InitialiseTimer1_PWM_OC1C_1Hz()
{
	TCCR1A = 0b00001011;	// Clear OC1C on Compare Match, Fast PWM (10-bit) waveform (TOP is 0x3FF) = 1023
	TCCR1B = 0b00001101;	// Fast PWM (10-bit) waveform generation, use prescaler 1024
	TCCR1C = 0b00000000;

	// For 1 MHz clock (with 1024 prescaler)
	// To achieve 1 second period, need to count 1000000 / 1024 = 976
	// To achieve 4 second period, need to count (1000000 / 1024) * 4 = 3904 = 0x
	TCNT1H = 0x00;
	TCNT1L = 0x00;
	OCR1CH = 0x01;	// Set to mid point (between 0x00 and 0x03FF) to achieve 50% duty cycle
	OCR1CL = 0xFF;

	TIMSK1 = 0b00000000;	// Do not need interrupts for the waveform - it is generated directly on the output pin
}
